package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval prism {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc prism::YYABORT {} {
    return -code return 1
}

proc prism::YYACCEPT {} {
    return -code return 0
}

proc prism::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc prism::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc prism::yyerror {s} {
    puts stderr $s
}

proc prism::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc prism::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set prism::table {
  11:265 shift
  0:266,target 2
  9:0 reduce
  0:265 shift
  5:265,target 10
  0:266 shift
  0:267 shift
  2:265 reduce
  0:265,target 1
  0:268 shift
  0:269 shift
  0:270 shift
  0:275,target 8
  4:265 shift
  6:0,target 14
  2:0 reduce
  6:265 reduce
  0:273 goto
  8:265 reduce
  0:275 goto
  6:0 reduce
  8:265,target 11
  7:0,target 0
  12:0 reduce
  0:0,target 13
  3:265,target 17
  10:0,target 16
  8:274 goto
  0:273,target 7
  8:274,target 11
  10:265,target 16
  3:0 reduce
  8:0,target 10
  1:0,target 15
  10:265 reduce
  6:265,target 14
  7:0 accept
  1:265,target 15
  9:0,target 19
  2:0,target 18
  12:0,target 12
  1:265 reduce
  0:0 reduce
  3:265 reduce
  9:265,target 19
  5:265 shift
  0:270,target 6
  0:269,target 5
  4:265,target 9
  9:265 reduce
  3:0,target 17
  8:0 reduce
  10:0 reduce
  11:265,target 12
  0:268,target 4
  1:0 reduce
  0:267,target 3
  2:265,target 18
}

array set prism::rules {
  9,l 272
  11,l 274
  15,l 275
  19,l 275
  2,l 271
  6,l 271
  12,l 273
  16,l 275
  3,l 271
  7,l 271
  13,l 275
  0,l 276
  17,l 275
  4,l 271
  8,l 272
  10,l 273
  14,l 275
  18,l 275
  1,l 271
  5,l 271
}

array set prism::rules {
  5,dc 1
  0,dc 1
  17,dc 1
  12,dc 3
  8,dc 1
  3,dc 1
  15,dc 1
  10,dc 1
  6,dc 1
  18,dc 1
  1,dc 0
  13,dc 0
  9,dc 1
  4,dc 1
  16,dc 2
  11,dc 0
  7,dc 1
  19,dc 2
  2,dc 1
  14,dc 1
}

array set prism::rules {
  13,line 57
  7,line 47
  10,line 53
  4,line 44
  18,line 62
  1,line 41
  15,line 59
  9,line 50
  12,line 54
  6,line 46
  3,line 43
  17,line 61
  14,line 58
  8,line 49
  11,line 53
  5,line 45
  19,line 63
  2,line 42
  16,line 60
  11,e 1
}

array set prism::lr1_table {
  0 {{0 0 0} {10 0 0} {12 0 0} {13 {0 265} 0} {14 {0 265} 0} {15 {0 265} 0} {16 {0 265} 0} {17 {0 265} 0} {18 {0 265} 0} {19 {0 265} 0}}
  1 {{15 {0 265} 1}}
  2 {{18 {0 265} 1}}
  3 {{17 {0 265} 1}}
  4 {{19 {0 265} 1}}
  0,trans {{265 1} {266 2} {267 3} {268 4} {269 5} {270 6} {273 7} {275 8}}
  5 {{16 {0 265} 1}}
  1,trans {}
  6 {{14 {0 265} 1}}
  2,trans {}
  3,trans {}
  7 {{0 0 1}}
  4,trans {{265 9}}
  8 {{10 0 1} {12 0 1} {11 265 0}}
  5,trans {{265 10}}
  10 {{16 {0 265} 2}}
  9 {{19 {0 265} 2}}
  11 {{12 0 2}}
  6,trans {}
  12 {{12 0 3}}
  7,trans {}
  8,trans {{274 11}}
  10,trans {}
  9,trans {}
  11,trans {{265 12}}
  12,trans {}
}

array set prism::token_id_table {
  264,line 15
  270,t 0
  269,t 0
  276,line 64
  265,title string
  274,t 1
  261,line 11
  257,t 0
  270,title OPEN
  269,title LOAD
  273,line 52
  257,line 7
  262,t 0
  274,title {}
  270,line 25
  269,line 24
  259,title ON
  260,title OFF
  266,t 0
  271,t 1
  error error
  264,title float
  266,line 21
  275,t 1
  error,line 39
  268,title CURRENT
  258,t 0
  263,line 14
  error,title {}
  275,line 56
  273,title {}
  263,t 0
  259,line 9
  260,line 10
  258,title NO
  272,line 48
  267,t 0
  263,title integer
  272,t 1
  268,line 23
  267,title CLOSE
  257 YES_
  276,t 1
  258 NO_
  259,t 0
  259 ON_
  260 OFF_
  260,t 0
  272,title {}
  261 TRUE_
  265,line 17
  262 FALSE_
  263 INT_
  257,title YES
  264 REAL_
  264,t 0
  276,title {}
  265 STRING_
  262,line 12
  266 CLEAR_
  267 CLOSE_
  0,t 0
  0 {$}
  262,title FALSE
  268 CURRENT_
  268,t 0
  274,line 53
  270 OPEN_
  269 LOAD_
  271 yesno
  error,t 0
  272 numeric
  258,line 8
  273,t 1
  273 command
  266,title CLEAR
  274 @PSEUDO1
  275 prism
  271,line 40
  276 start'
  271,title {}
  261,t 0
  267,line 22
  275,title {}
  265,t 0
  261,title TRUE
}

proc prism::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ 1 }
                    2 { set _ 1 }
                    3 { set _ 1 }
                    4 { set _ 1 }
                    5 { set _ 0 }
                    6 { set _ 0 }
                    7 { set _ 0 }
                    8 { set _ $1 }
                    9 { set _ $1 }
                    11 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    13 { PrismDialog prism }
                    14 { PrismDialog prism }
                    15 { PrismCmdLoad $1 }
                    16 { PrismCmdCVAR0 PrismdLoad $2 }
                    17 { ProcessCmdCVAR0 PrismDestroy }
                    18 { ProcessCmdCVAR0 PrismClear }
                    19 { PrismCmdRef $2 }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc prism::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
